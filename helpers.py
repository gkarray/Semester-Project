import time
from numpy import array, ceil, complex, exp, pi, zeros
from numpy.random import rand, randint, randn
from numpy.fft import irfft, fft, fftfreq, fftshift, ifft
from scipy.signal import firwin, lfilter
import numpy as np
import scipy

def get_spike_signal(z, qs, N, theta):
    """
    To be optimized
    """
    minus_ones = np.where(qs==-1)
    ones = np.where(qs==1)
    minus_ones_idx = z[minus_ones]
    ones_idx = z[ones]
    minus_impulse = scipy.signal.unit_impulse(N, minus_ones_idx) * -1
    ones_impulse = scipy.signal.unit_impulse(N, ones_idx)
    impulses = minus_impulse + ones_impulse
    impulses = impulses * theta
    
    return impulses

def rcosfilter(t, gamma, Ts):
    """
    To be optimized
    """
    return np.sinc(t/Ts) * np.cos(np.pi*gamma*t/Ts) / (1 - (2*gamma*t/Ts) ** 2)

def derivative_rcosfilter(t, gamma, Ts):
    a = np.sinc(t/Ts)
    a_prime = (np.cos(np.pi * t / Ts) - np.sinc(t/Ts)) / t
    
    b = np.cos(np.pi * gamma * t / Ts)
    b_prime = - (np.pi * gamma / Ts) * np.sin(np.pi * gamma * t / Ts)
    
    c = 1 / (1 - (2*gamma*t/Ts) ** 2)
    c_prime = (8 * ((Ts * gamma) **2) * t) / ((Ts**2 - (2*gamma*t) ** 2) **2)
    
    return a * b * c_prime + a * b_prime * c + a_prime * b * c

def closed_phi_from_rcos(t, gamma, Ts, alpha):
    """
    To be optimized
    """
    return derivative_rcosfilter(t, gamma, Ts) + alpha * rcosfilter(t, gamma, Ts) 

def get_phi_from_psi(psi_kernel, N, dt, alpha):
    """
    To be optimized
    """
    fft_psi = fft(psi_kernel)
    fft_xf = fftfreq(N, dt)
    
    fft_phi = (2*np.pi*fft_xf*1j + alpha) * fft_psi
    phi = ifft(fft_phi)
    
    return phi


def gen_band_limited(dur, dt, fmax, np=None, nc=3):
    """
    Generate a uniformly sampled, band-limited signal.

    Parameters
    ----------
    dur : float
        Duration of signal (s).
    dt : float
        Sampling resolution; the sampling frequency is 1/dt Hz.
    fmax : float
        Maximum frequency (Hz).
    np : float
        Noise power. If `np != None`, Gaussian white noise is added to the
        generated signal before the latter is filtered.
    nc : int
        Number of discrete frequency components in generated signal.

    Returns
    -------
    u : ndarray of floats
        Generated signal.

    """

    # Since the signal generated by this function must be real, the
    # frequency components on one side of its fft representation are
    # complex conjugates of those on the other side; this allows for
    # the use of the inverse real fft (irfft), which only requires the
    # frequency components on one side of the full fft as input (and
    # hence allows this function to consume less memory when run).

    # The maximum frequency may not exceed the Nyquist frequency:
    fs = 1.0/dt
    if fmax > fs/2:
        raise ValueError("maximum frequency may not exceed the Nyquist frequency")

    # Determine number of entries in generated signal. This
    # corresponds to the length of arange(0, dur, dt):
    n = int(ceil(dur/dt))

    # Randomly set nc distinct frequency components:    
    f = zeros(int(n/2)+1, complex) # only one side of the spectrum is needed
    fmaxi = int(n*fmax/fs)
    if fmaxi < nc:
        raise ValueError("maximum frequency %f is too low to provide %i frequency components" % (fmax, nc))

    # The first element in the fft corresponds to the DC component;
    # hence, it is not set:
    ci = set()
    while len(ci) < nc:
        temp = randint(1, fmaxi+1)
        while temp in ci:
            temp = randint(1, fmaxi+1)
        ci.add(temp)
    ci = array(list(ci))
    p = -2*pi*rand(nc)
    f[ci] = (n/2)*exp(1j*p)

    # Create the signal by transforming the constructed frequency
    # representation into the time domain and adding white noise if so
    # specified:
    u = irfft(f,n)
    if np != None:
        u += randn(len(u))*10**(np/20)

    # Filter the result to get rid of high frequency components
    # introduced by the noise. Since a cutoff of 1 corresponds to the
    # Nyquist frequency 1/(2*dt), the cutoff corresponding to the
    # frequency fmax must be fmax/(1/2*dt):
    b = firwin(40, 2*fmax*dt)
    u = lfilter(b, 1, u)

    return u